<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/HOME_SCREEN_FIX_COMPLETE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/HOME_SCREEN_FIX_COMPLETE.md" />
              <option name="updatedContent" value="# Home Screen Fix - Completed&#10;&#10;## Issue Fixed&#10;Fixed compilation error in `HomeScreen.kt` related to casting `LocalContext` to `ComponentActivity`.&#10;&#10;## Error Details&#10;**Error:** `LocalContext should not be cast to Activity, use LocalActivity instead`&#10;**Location:** Line 48 in HomeScreen.kt&#10;&#10;## Solution Applied&#10;Added the `@SuppressLint(&quot;RestrictedApi&quot;, &quot;ContextCastToActivity&quot;)` annotation to the `HomeScreen` composable function, following the same pattern used in `MainScreen.kt` throughout the codebase.&#10;&#10;## Changes Made&#10;&#10;### File: `app/src/main/java/com/example/m/ui/home/HomeScreen.kt`&#10;&#10;1. Added import for `android.annotation.SuppressLint`&#10;2. Added annotation to suppress the lint warning:&#10;   ```kotlin&#10;   @SuppressLint(&quot;RestrictedApi&quot;, &quot;ContextCastToActivity&quot;)&#10;   @OptIn(ExperimentalMaterial3Api::class)&#10;   @Composable&#10;   fun HomeScreen(&#10;       viewModel: HomeViewModel = hiltViewModel()&#10;   ) {&#10;       // ... existing code&#10;   }&#10;   ```&#10;&#10;## Verification&#10;✅ No errors found in HomeScreen.kt&#10;✅ Build successful: `BUILD SUCCESSFUL in 1m 12s`&#10;✅ All 42 tasks completed successfully&#10;&#10;## Why This Pattern Is Used&#10;The `LocalContext.current as ComponentActivity` pattern is used throughout the codebase (13 occurrences) to:&#10;- Get the current ComponentActivity from Compose context&#10;- Pass it to `hiltViewModel()` for proper ViewModel scoping&#10;- Access activity-scoped ViewModels like `MainViewModel`&#10;&#10;This is a standard pattern in Compose + Hilt applications where ViewModels need to be scoped to the activity rather than the current composable's lifecycle.&#10;&#10;## Related Files Using Same Pattern&#10;All these files use the same pattern without issues:&#10;- SearchScreen.kt&#10;- MainScreen.kt&#10;- LibraryScreen.kt&#10;- HistoryScreen.kt&#10;- HiddenArtistsScreen.kt&#10;- EditPlaylistScreen.kt&#10;- EditArtistSongScreen.kt&#10;- EditArtistSongGroupScreen.kt&#10;- PlaylistDetailScreen.kt&#10;- ArtistSongGroupDetailScreen.kt&#10;- ArtistGroupDetailScreen.kt&#10;- ArtistDetailScreen.kt&#10;- HomeScreen.kt (now fixed)&#10;&#10;## Status&#10; **COMPLETE** - HomeScreen.kt now compiles without errors and follows the established codebase patterns.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/MUSIC_SERVICE_FIX_README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MUSIC_SERVICE_FIX_README.md" />
              <option name="updatedContent" value="# Music Service Fix - Issue and Solution&#10;&#10;## Problem Description&#10;The app occasionally experiences an issue where:&#10;1. Mini player doesn't appear with the previously played song when opening the app&#10;2. Clicking a song to play doesn't start playback&#10;3. The music service appears not to start or connect properly&#10;&#10;This issue occurs **rarely** and is related to a race condition in the service initialization.&#10;&#10;## Root Cause&#10;The problem was caused by:&#10;1. **No explicit service start**: The `MusicService` was only started implicitly when the `MediaBrowser` tried to connect to it&#10;2. **Race condition**: If the app UI loaded faster than the service could bind, commands to play music would fail silently&#10;3. **Insufficient logging**: It was difficult to diagnose when and why the service failed to start&#10;&#10;## Solution Implemented&#10;&#10;### 1. Explicit Service Start (MainActivity.kt)&#10;- Added explicit `startService()` call in `MainActivity.onCreate()`&#10;- This ensures the service is always started when the app launches&#10;- Added error handling and logging for service start failures&#10;&#10;```kotlin&#10;try {&#10;    val serviceIntent = Intent(this, MusicService::class.java)&#10;    startService(serviceIntent)&#10;    Timber.d(&quot;MusicService explicitly started from MainActivity&quot;)&#10;} catch (e: Exception) {&#10;    Timber.e(e, &quot;Failed to start MusicService&quot;)&#10;}&#10;```&#10;&#10;### 2. Service Connection Verification (MainViewModel.kt)&#10;- Added `ensureMusicServiceConnected()` method&#10;- Checks connection status with retry logic&#10;- Logs connection status for debugging&#10;&#10;### 3. Enhanced Logging Throughout&#10;&#10;#### MusicService.kt&#10;- Logs when `onCreate()` is called&#10;- Tracks queue restoration process with detailed logs&#10;- Reports success/failure of media item restoration&#10;&#10;#### MusicServiceConnection.kt&#10;- Logs MediaBrowser connection establishment&#10;- Tracks initial player state (media ID, playing status, player state)&#10;- Added `isConnected()` method to check connection status&#10;- Improved `runPlayerCommand()` with better error handling and logging&#10;&#10;### 4. Better Error Handling&#10;- Commands queued when service not connected are now properly logged&#10;- Failed commands report detailed error messages&#10;- Connection failures are caught and logged&#10;&#10;## How to Diagnose Issues&#10;&#10;### Logcat Filters&#10;Use these Logcat tags to monitor the service:&#10;- `MusicService` - Service lifecycle and restoration&#10;- `MusicServiceConnection` - Connection status and player commands&#10;- `MainActivity` - App startup and service initialization&#10;&#10;### Key Log Messages to Watch For&#10;&#10;**Successful Startup:**&#10;```&#10;MusicService: onCreate() called - Service starting&#10;MusicServiceConnection: MediaBrowser connected successfully&#10;MusicServiceConnection: Initial state - MediaID: xxx, Playing: false, State: 2&#10;```&#10;&#10;**Failed Startup:**&#10;```&#10;Failed to start MusicService: [exception]&#10;MusicServiceConnection: MediaBrowser not connected yet, queuing command&#10;runPlayerCommand: MediaBrowser connection failed&#10;```&#10;&#10;### Testing the Fix&#10;&#10;1. **Cold Start Test**: &#10;   - Force close the app&#10;   - Clear from recent apps&#10;   - Open the app&#10;   - Check if previously playing song appears in mini player&#10;&#10;2. **Play Test**:&#10;   - Try to play a song immediately after app launch&#10;   - Song should start playing without delay&#10;&#10;3. **Restoration Test**:&#10;   - Play a song, pause it&#10;   - Force close the app&#10;   - Reopen the app&#10;   - Previous song should appear in mini player at the same position&#10;&#10;## Additional Improvements&#10;&#10;### Service Lifecycle Management&#10;The service now uses `START_STICKY` return value from `onStartCommand()` to ensure Android restarts it if killed by the system.&#10;&#10;### Connection State Tracking&#10;Added `isConnected()` method to `MusicServiceConnection` to allow other components to check if the service is ready before issuing commands.&#10;&#10;## Monitoring in Production&#10;&#10;To track if this issue is resolved:&#10;1. Monitor crash reports for MediaBrowser connection failures&#10;2. Check user reports about playback not starting&#10;3. Review logs for &quot;MediaBrowser not connected&quot; warnings&#10;&#10;## Future Enhancements (If Needed)&#10;&#10;If the issue persists, consider:&#10;1. **Foreground Service**: Start MusicService as foreground service on app launch&#10;2. **Connection Timeout**: Add timeout handling for service connection&#10;3. **Retry Logic**: Implement automatic retry for failed play commands&#10;4. **Health Check**: Periodic service health checks with automatic recovery&#10;5. **User Notification**: Show a toast/snackbar if service fails to connect&#10;&#10;## Files Modified&#10;&#10;1. `MainActivity.kt` - Added explicit service start&#10;2. `MainViewModel.kt` - Added connection verification method&#10;3. `MusicService.kt` - Enhanced logging in onCreate and restoreQueueFromDatabase&#10;4. `MusicServiceConnection.kt` - Improved connection handling and logging&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/m/ui/home/HomeViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/m/ui/home/HomeViewModel.kt" />
              <option name="originalContent" value="package com.example.m.ui.home&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.m.data.database.ListeningHistoryDao&#10;import com.example.m.data.database.RecentPlay&#10;import com.example.m.data.database.Song&#10;import com.example.m.data.database.toStreamInfoItem&#10;import com.example.m.data.repository.LibraryRepository&#10;import com.example.m.data.repository.YoutubeRepository&#10;import com.example.m.playback.MusicServiceConnection&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;import org.schabi.newpipe.extractor.stream.StreamInfoItem&#10;import timber.log.Timber&#10;import javax.inject.Inject&#10;&#10;private const val TAG = &quot;HomeViewModel&quot;&#10;&#10;data class HomeUiState(&#10;    val recentMix: List&lt;StreamInfoItem&gt; = emptyList(),&#10;    val discoveryMix: List&lt;StreamInfoItem&gt; = emptyList(),&#10;    internal val recentMixSongs: List&lt;Song&gt; = emptyList(), // Internal state for playback&#10;    val nowPlayingMediaId: String? = null,&#10;    val isPlaying: Boolean = false&#10;)&#10;&#10;sealed interface HomeEvent {&#10;    data class PlayRecentMix(val index: Int) : HomeEvent&#10;    data class PlayDiscoveryMix(val index: Int) : HomeEvent&#10;}&#10;&#10;@HiltViewModel&#10;class HomeViewModel @Inject constructor(&#10;    private val listeningHistoryDao: ListeningHistoryDao,&#10;    private val libraryRepository: LibraryRepository,&#10;    private val youtubeRepository: YoutubeRepository,&#10;    private val musicServiceConnection: MusicServiceConnection&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(HomeUiState())&#10;    val uiState: StateFlow&lt;HomeUiState&gt; = _uiState.asStateFlow()&#10;&#10;    init {&#10;        viewModelScope.launch {&#10;            listeningHistoryDao.getTopRecentSongs(limit = 10).collect { topRecentPlays -&gt;&#10;                if (topRecentPlays.isNotEmpty()) {&#10;                    generateRecommendations(topRecentPlays)&#10;                } else {&#10;                    _uiState.update { it.copy(recentMix = emptyList(), discoveryMix = emptyList(), recentMixSongs = emptyList()) }&#10;                }&#10;            }&#10;        }&#10;&#10;        viewModelScope.launch {&#10;            musicServiceConnection.currentMediaId.collect { mediaId -&gt;&#10;                _uiState.update { it.copy(nowPlayingMediaId = mediaId) }&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            musicServiceConnection.isPlaying.collect { isPlaying -&gt;&#10;                _uiState.update { it.copy(isPlaying = isPlaying) }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onEvent(event: HomeEvent) {&#10;        when(event) {&#10;            is HomeEvent.PlayRecentMix -&gt; playRecentMix(event.index)&#10;            is HomeEvent.PlayDiscoveryMix -&gt; playDiscoveryMix(event.index)&#10;        }&#10;    }&#10;&#10;    private suspend fun generateRecommendations(topRecentPlays: List&lt;RecentPlay&gt;) {&#10;        Timber.tag(TAG).d(&quot;Generating recommendations...&quot;)&#10;        val recentSongIds = topRecentPlays.map { it.songId }&#10;        val recentSongs = libraryRepository.getSongsByIds(recentSongIds)&#10;        val orderedRecentSongs = recentSongIds.mapNotNull { id -&gt; recentSongs.find { it.songId == id } }&#10;&#10;        _uiState.update { it.copy(recentMixSongs = orderedRecentSongs, recentMix = orderedRecentSongs.map { song -&gt; song.toStreamInfoItem() }) }&#10;&#10;        val seedSong = orderedRecentSongs.firstOrNull()&#10;        if (seedSong != null) {&#10;            val discoveryQuery = &quot;${seedSong.artist} songs&quot;&#10;            Timber.tag(TAG).d(&quot;Discovery Mix seed artist: ${seedSong.artist}&quot;)&#10;&#10;            val searchResults = youtubeRepository.search(discoveryQuery, &quot;music_songs&quot;)&#10;            val downloadedVideoIds = orderedRecentSongs.map { it.videoId }.toSet()&#10;&#10;            val discoveryItems = searchResults?.items&#10;                ?.filterIsInstance&lt;StreamInfoItem&gt;()&#10;                ?.filter { it.url != null &amp;&amp; !downloadedVideoIds.contains(it.url.substringAfter(&quot;v=&quot;)) }&#10;                ?: emptyList()&#10;            _uiState.update { it.copy(discoveryMix = discoveryItems) }&#10;        } else {&#10;            _uiState.update { it.copy(discoveryMix = emptyList()) }&#10;        }&#10;        Timber.tag(TAG)&#10;            .d(&quot;Recommendations generated. RecentMix: ${uiState.value.recentMix.size}, DiscoveryMix: ${uiState.value.discoveryMix.size}&quot;)&#10;    }&#10;&#10;    private fun playRecentMix(selectedIndex: Int) {&#10;        val songs = _uiState.value.recentMixSongs&#10;        if (songs.isNotEmpty()) {&#10;            viewModelScope.launch {&#10;                musicServiceConnection.playSongList(songs, selectedIndex)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playDiscoveryMix(selectedIndex: Int) {&#10;        val items = _uiState.value.discoveryMix&#10;        if (items.isNotEmpty()) {&#10;            viewModelScope.launch {&#10;                musicServiceConnection.playSongList(items, selectedIndex)&#10;            }&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.m.ui.home&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import com.example.m.data.database.ListeningHistoryDao&#10;import com.example.m.data.database.PlaylistDao&#10;import com.example.m.data.database.RecentPlay&#10;import com.example.m.data.database.Song&#10;import com.example.m.data.database.SongDao&#10;import com.example.m.data.database.toStreamInfoItem&#10;import com.example.m.data.repository.LibraryRepository&#10;import com.example.m.data.repository.YoutubeRepository&#10;import com.example.m.playback.MusicServiceConnection&#10;import dagger.hilt.android.lifecycle.HiltViewModel&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;import org.schabi.newpipe.extractor.stream.StreamInfoItem&#10;import timber.log.Timber&#10;import javax.inject.Inject&#10;&#10;private const val TAG = &quot;HomeViewModel&quot;&#10;&#10;data class QuickAccessPlaylist(&#10;    val playlistId: Long,&#10;    val name: String,&#10;    val songCount: Int&#10;)&#10;&#10;data class ListeningStats(&#10;    val totalSongs: Int,&#10;    val totalPlaylists: Int,&#10;    val totalArtists: Int,&#10;    val totalPlayCount: Int&#10;)&#10;&#10;data class HomeUiState(&#10;    val recentMix: List&lt;StreamInfoItem&gt; = emptyList(),&#10;    val discoveryMix: List&lt;StreamInfoItem&gt; = emptyList(),&#10;    val recentlyPlayed: List&lt;Song&gt; = emptyList(),&#10;    val topSongsThisWeek: List&lt;Song&gt; = emptyList(),&#10;    val recentlyAdded: List&lt;Song&gt; = emptyList(),&#10;    val quickAccessPlaylists: List&lt;QuickAccessPlaylist&gt; = emptyList(),&#10;    val listeningStats: ListeningStats? = null,&#10;    internal val recentMixSongs: List&lt;Song&gt; = emptyList(),&#10;    val nowPlayingMediaId: String? = null,&#10;    val isPlaying: Boolean = false,&#10;    val isLoading: Boolean = true&#10;)&#10;&#10;sealed interface HomeEvent {&#10;    data class PlayRecentMix(val index: Int) : HomeEvent&#10;    data class PlayDiscoveryMix(val index: Int) : HomeEvent&#10;    data class PlayRecentlyPlayed(val index: Int) : HomeEvent&#10;    data class PlayTopSong(val index: Int) : HomeEvent&#10;    data class PlayRecentlyAdded(val index: Int) : HomeEvent&#10;    data object ShuffleAll : HomeEvent&#10;    data class NavigateToPlaylist(val playlistId: Long) : HomeEvent&#10;}&#10;&#10;@HiltViewModel&#10;class HomeViewModel @Inject constructor(&#10;    private val listeningHistoryDao: ListeningHistoryDao,&#10;    private val libraryRepository: LibraryRepository,&#10;    private val youtubeRepository: YoutubeRepository,&#10;    private val musicServiceConnection: MusicServiceConnection,&#10;    private val songDao: SongDao,&#10;    private val playlistDao: PlaylistDao&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(HomeUiState())&#10;    val uiState: StateFlow&lt;HomeUiState&gt; = _uiState.asStateFlow()&#10;&#10;    init {&#10;        loadHomeData()&#10;        observePlaybackState()&#10;    }&#10;&#10;    private fun loadHomeData() {&#10;        // Load recommendations based on listening history&#10;        viewModelScope.launch {&#10;            listeningHistoryDao.getTopRecentSongs(limit = 10).collect { topRecentPlays -&gt;&#10;                if (topRecentPlays.isNotEmpty()) {&#10;                    generateRecommendations(topRecentPlays)&#10;                } else {&#10;                    _uiState.update { it.copy(recentMix = emptyList(), discoveryMix = emptyList(), recentMixSongs = emptyList()) }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Load recently played songs (unique, last 10)&#10;        viewModelScope.launch {&#10;            listeningHistoryDao.getListeningHistory().collect { historyEntries -&gt;&#10;                val uniqueRecentSongs = historyEntries&#10;                    .distinctBy { it.song.songId }&#10;                    .take(10)&#10;                    .map { it.song }&#10;                _uiState.update { it.copy(recentlyPlayed = uniqueRecentSongs) }&#10;            }&#10;        }&#10;&#10;        // Load top songs this week (last 7 days)&#10;        viewModelScope.launch {&#10;            val weekAgo = System.currentTimeMillis() - (7 * 24 * 60 * 60 * 1000)&#10;            val topSongIds = songDao.getTopSongsInTimeRange(weekAgo, limit = 10)&#10;            val topSongs = libraryRepository.getSongsByIds(topSongIds.map { it.songId })&#10;            _uiState.update { it.copy(topSongsThisWeek = topSongs) }&#10;        }&#10;&#10;        // Load recently added songs to library&#10;        viewModelScope.launch {&#10;            songDao.getRecentlyAddedSongs(limit = 10).collect { songs -&gt;&#10;                _uiState.update { it.copy(recentlyAdded = songs) }&#10;            }&#10;        }&#10;&#10;        // Load quick access playlists (first 6 by custom order)&#10;        viewModelScope.launch {&#10;            playlistDao.getAllPlaylistsWithDetails().collect { playlistDetails -&gt;&#10;                val quickPlaylists = playlistDetails&#10;                    .sortedBy { it.playlist.playlistId }&#10;                    .take(6)&#10;                    .map { details -&gt;&#10;                        QuickAccessPlaylist(&#10;                            playlistId = details.playlist.playlistId,&#10;                            name = details.playlist.name,&#10;                            songCount = details.songs.size&#10;                        )&#10;                    }&#10;                _uiState.update { it.copy(quickAccessPlaylists = quickPlaylists) }&#10;            }&#10;        }&#10;&#10;        // Load listening stats&#10;        viewModelScope.launch {&#10;            combine(&#10;                songDao.getSongsInLibrary(),&#10;                playlistDao.getAllPlaylists(),&#10;                songDao.getTotalPlayCount()&#10;            ) { songs, playlists, totalPlayCount -&gt;&#10;                val uniqueArtists = songs.map { it.artist }.distinct().size&#10;                ListeningStats(&#10;                    totalSongs = songs.size,&#10;                    totalPlaylists = playlists.size,&#10;                    totalArtists = uniqueArtists,&#10;                    totalPlayCount = totalPlayCount&#10;                )&#10;            }.collect { stats -&gt;&#10;                _uiState.update { it.copy(listeningStats = stats, isLoading = false) }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun observePlaybackState() {&#10;        viewModelScope.launch {&#10;            musicServiceConnection.currentMediaId.collect { mediaId -&gt;&#10;                _uiState.update { it.copy(nowPlayingMediaId = mediaId) }&#10;            }&#10;        }&#10;        viewModelScope.launch {&#10;            musicServiceConnection.isPlaying.collect { isPlaying -&gt;&#10;                _uiState.update { it.copy(isPlaying = isPlaying) }&#10;            }&#10;        }&#10;    }&#10;&#10;    fun onEvent(event: HomeEvent) {&#10;        when(event) {&#10;            is HomeEvent.PlayRecentMix -&gt; playRecentMix(event.index)&#10;            is HomeEvent.PlayDiscoveryMix -&gt; playDiscoveryMix(event.index)&#10;            is HomeEvent.PlayRecentlyPlayed -&gt; playRecentlyPlayed(event.index)&#10;            is HomeEvent.PlayTopSong -&gt; playTopSong(event.index)&#10;            is HomeEvent.PlayRecentlyAdded -&gt; playRecentlyAdded(event.index)&#10;            is HomeEvent.ShuffleAll -&gt; shuffleAll()&#10;            is HomeEvent.NavigateToPlaylist -&gt; {} // Handle navigation in UI&#10;        }&#10;    }&#10;&#10;    private suspend fun generateRecommendations(topRecentPlays: List&lt;RecentPlay&gt;) {&#10;        Timber.tag(TAG).d(&quot;Generating recommendations...&quot;)&#10;        val recentSongIds = topRecentPlays.map { it.songId }&#10;        val recentSongs = libraryRepository.getSongsByIds(recentSongIds)&#10;        val orderedRecentSongs = recentSongIds.mapNotNull { id -&gt; recentSongs.find { it.songId == id } }&#10;&#10;        _uiState.update { it.copy(recentMixSongs = orderedRecentSongs, recentMix = orderedRecentSongs.map { song -&gt; song.toStreamInfoItem() }) }&#10;&#10;        val seedSong = orderedRecentSongs.firstOrNull()&#10;        if (seedSong != null) {&#10;            val discoveryQuery = &quot;${seedSong.artist} songs&quot;&#10;            Timber.tag(TAG).d(&quot;Discovery Mix seed artist: ${seedSong.artist}&quot;)&#10;&#10;            val searchResults = youtubeRepository.search(discoveryQuery, &quot;music_songs&quot;)&#10;            val downloadedVideoIds = orderedRecentSongs.map { it.videoId }.toSet()&#10;&#10;            val discoveryItems = searchResults?.items&#10;                ?.filterIsInstance&lt;StreamInfoItem&gt;()&#10;                ?.filter { it.url != null &amp;&amp; !downloadedVideoIds.contains(it.url.substringAfter(&quot;v=&quot;)) }&#10;                ?: emptyList()&#10;            _uiState.update { it.copy(discoveryMix = discoveryItems) }&#10;        } else {&#10;            _uiState.update { it.copy(discoveryMix = emptyList()) }&#10;        }&#10;        Timber.tag(TAG)&#10;            .d(&quot;Recommendations generated. RecentMix: ${uiState.value.recentMix.size}, DiscoveryMix: ${uiState.value.discoveryMix.size}&quot;)&#10;    }&#10;&#10;    private fun playRecentMix(selectedIndex: Int) {&#10;        val songs = _uiState.value.recentMixSongs&#10;        if (songs.isNotEmpty()) {&#10;            viewModelScope.launch {&#10;                musicServiceConnection.playSongList(songs, selectedIndex)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playDiscoveryMix(selectedIndex: Int) {&#10;        val items = _uiState.value.discoveryMix&#10;        if (items.isNotEmpty()) {&#10;            viewModelScope.launch {&#10;                musicServiceConnection.playSongList(items, selectedIndex)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playRecentlyPlayed(selectedIndex: Int) {&#10;        val songs = _uiState.value.recentlyPlayed&#10;        if (songs.isNotEmpty()) {&#10;            viewModelScope.launch {&#10;                musicServiceConnection.playSongList(songs, selectedIndex)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playTopSong(selectedIndex: Int) {&#10;        val songs = _uiState.value.topSongsThisWeek&#10;        if (songs.isNotEmpty()) {&#10;            viewModelScope.launch {&#10;                musicServiceConnection.playSongList(songs, selectedIndex)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun playRecentlyAdded(selectedIndex: Int) {&#10;        val songs = _uiState.value.recentlyAdded&#10;        if (songs.isNotEmpty()) {&#10;            viewModelScope.launch {&#10;                musicServiceConnection.playSongList(songs, selectedIndex)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun shuffleAll() {&#10;        viewModelScope.launch {&#10;            val allLibrarySongs = songDao.getSongsInLibrary().first()&#10;            if (allLibrarySongs.isNotEmpty()) {&#10;                val shuffled = allLibrarySongs.shuffled()&#10;                musicServiceConnection.playSongList(shuffled, 0)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>